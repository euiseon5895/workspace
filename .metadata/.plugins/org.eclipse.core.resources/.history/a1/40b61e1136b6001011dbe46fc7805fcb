package chOmok;



import java.util.Scanner;

public class Omok {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);

		// 사용자 이름을 입력받는다
		System.out.print("사용자1 이름을 입력하세요: ");
		Player user = new Player(scan.nextLine(), "O");

		System.out.print("사용자2 이름을 입력하세요: ");
		Player computer = new Player(scan.nextLine(), "X");
		Board board = new Board(19);

		// 게임 시작
		play(board, user, computer);
	}

	private static void play(Board board, Player user1, Player user2) {
		board.print();

		Scanner scanner = new Scanner(System.in);

		boolean isStop = false; // 게임 종료 flag

		int turn = 1; // 사용자 턴 구분 (1: user1 / 2: user2)
		
		int row, col; // 사용자 입력 좌표 저장
		String line; 
        String[] parts;
        
        // 1. 공백을 기준으로 문자열 분리
		Player currentPlayer;

		// 오목 되면 프로그램 종료
		while (!isStop) {

			// 턴
			if (turn == 1) currentPlayer = user1;
			else currentPlayer = user2;

			// 1. 사용자 좌표 입력받음 "A 0"
			System.out.print(currentPlayer.name + "> ");
			line = scanner.nextLine();
			parts = line.split(" ");
			
			row =  Integer.parseInt(parts[1]);	// "0"
			col = parts[0].charAt(0) - 65; 		// "A"

			// 2. 입력 좌표 유효한지 확인 
			if (row > 18 || col > 18 || board.map[row][col] != ".") {
				System.out.println("해당 위치에는 돌을 둘 수 없습니다\n");
				continue;
			}
			/* 숫자가 아닌 문자가 들어왔을 때 처리필요 */

			// 입력 좌표를 보드에 반영
			board.map[row][col] = currentPlayer.stone;

			// 3. 오목 검사
			if (Ocheck(board, currentPlayer.stone, row, col)) {
				isStop = true;
				System.out.println("=====================================");
				System.out.println("[" + currentPlayer.name + "] WIN!");
			} else {
				// 턴 바꾸기
				if (turn == 1) turn = 0;
				else turn = 1;
			}

			// 3. 보드 프린트
			board.print();
		}

		// 종료
		System.out.println("=====================================");
		System.out.println("To be continued...");
	}

	private static boolean Ocheck(Board board, String stone, int x, int y) {
		int cnt = 0;
		int row, col;
		
		// 세로로 검사
		for (row = 0; row < board.size; row++) {
			if (board.map[row][y].equals(stone)) cnt++;
			else cnt=0;
			
			if(cnt == 5) return true; 
		}
		cnt = 0; // 초기화
		
		// 가로로 검사
		for (col = 0; col < board.size; col++) {
			if (board.map[x][col].equals(stone)) cnt++;
			else cnt = 0;
			
			if (cnt == 5) return true; 
		}
		cnt = 0;
		
		// \ (우하향)방향 검사
		// 좌상단 시작점을 먼저 찾음 -> 시작점 x, y 둘 중 하나는 무조건 0
		// min(x,y) 좌표가 0 (3,2)인 경우 시작점 중 y가 0이 됨, x는 y-x
		int startX = x - Math.min(x, y);
		int startY = y - Math.min(x, y); 
		for(row = startX, col = startY; row < board.size && col < board.size; row++, col++) {
			if (board.map[row][col].equals(stone)) cnt++;
			else cnt = 0;
			
			if (cnt == 5) return true; 
		}
		cnt = 0;
//		for (int num = 0; num < board.size; num++) {
//			if (board.map[num][num].equals(stone)) {
//				cnt++;
//				if (cnt == 5) return true; 
//				else cnt = 0;
//			}
//		}
		
		// / (우상향)방향 검사
		// x와 y의 합이 항상 같음
		// 합이 board의 size보다 큰 경우 작은경우로 나눔
		// 작은 경우에는 x가 sum이 되고, 큰 경우에는 board 사이즈-1 이 됨
		int sum = x + y;
		startX = sum >= board.size ? board.size - 1 : sum;
		startY = sum - startX;
		
		for(row = startX, col = startY; row >= 0 && col < board.size; row--, col++) {
			if (board.map[row][col].equals(stone)) cnt++;
			else cnt = 0;
			
			if (cnt == 5) return true; 
		}
		
//		for (int num = 0; num < board.size; num++) {
//			if (board.map[num][board.size -1 - num].equals(stone)) {
//				cnt++;
//				if (cnt == 5) return true;
//				else cnt = 0;
//			}
//		}

		return false;
	}

}